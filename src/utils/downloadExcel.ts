
import * as XLSX from 'xlsx';

export const downloadAsExcel = async (
  data: Array<Record<string, any>>,
  title: string,
  source?: string
): Promise<void> => {
  try {
    // Create a new workbook
    const workbook = XLSX.utils.book_new();
    
    // Add metadata sheet with better formatting
    const metadataSheet = XLSX.utils.aoa_to_sheet([
      ['REPORT DETAILS', ''],
      ['Report Title', title || 'Data Extraction Report'],
      ['Generated On', new Date().toLocaleString('en-IN')],
      ['Source Document', source || 'AI Research Assistant'],
      ['Total Records', data.length.toString()],
      ['Extraction Method', 'AI-Powered Analysis'],
      [''],
      ['SUMMARY STATISTICS', ''],
      ['Fields Extracted', Object.keys(data[0] || {}).length.toString()],
      ['Report Status', 'Complete'],
      [''],
      ['Generated by Data Extractor Pro - AI Research Assistant']
    ]);
    
    // Style the metadata sheet
    metadataSheet['A1'].s = {
      font: { bold: true, sz: 14, color: { rgb: "FFFFFF" } },
      fill: { fgColor: { rgb: "2563EB" } },
      alignment: { horizontal: "center" }
    };
    
    XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Report Info');
    
    // Prepare main data - ensure S.No is first column
    const dataWithSerial = data.map((row, index) => {
      const newRow: Record<string, any> = { 'S.No': index + 1 };
      
      // Add all other fields, maintaining order
      Object.keys(row).forEach(key => {
        if (key !== 'S.No') {
          newRow[key] = row[key] || '-';
        }
      });
      
      return newRow;
    });
    
    // Create main data sheet with enhanced formatting
    const dataSheet = XLSX.utils.json_to_sheet(dataWithSerial);
    
    // Calculate column widths intelligently
    const headers = Object.keys(dataWithSerial[0] || {});
    const colWidths = headers.map(header => {
      const maxContentLength = Math.max(
        header.length,
        ...dataWithSerial.map(row => String(row[header] || '').length)
      );
      
      // Set reasonable min/max widths
      return {
        wch: Math.min(Math.max(maxContentLength + 2, 10), 50)
      };
    });
    
    dataSheet['!cols'] = colWidths;
    
    // Enhanced header styling
    const range = XLSX.utils.decode_range(dataSheet['!ref'] || 'A1');
    
    // Style headers with gradient-like effect
    for (let col = range.s.c; col <= range.e.c; col++) {
      const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
      if (!dataSheet[cellAddress]) continue;
      
      dataSheet[cellAddress].s = {
        font: { 
          bold: true, 
          sz: 11, 
          color: { rgb: "FFFFFF" },
          name: "Calibri"
        },
        fill: { fgColor: { rgb: "1E40AF" } },
        alignment: { 
          horizontal: "center", 
          vertical: "center",
          wrapText: true
        },
        border: {
          top: { style: "thin", color: { rgb: "000000" } },
          bottom: { style: "thin", color: { rgb: "000000" } },
          left: { style: "thin", color: { rgb: "000000" } },
          right: { style: "thin", color: { rgb: "000000" } }
        }
      };
    }
    
    // Style data rows with alternating colors
    for (let row = range.s.r + 1; row <= range.e.r; row++) {
      const isEvenRow = (row - 1) % 2 === 0;
      
      for (let col = range.s.c; col <= range.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
        if (!dataSheet[cellAddress]) dataSheet[cellAddress] = { v: '', t: 's' };
        
        dataSheet[cellAddress].s = {
          font: { 
            sz: 10,
            name: "Calibri",
            color: { rgb: "1F2937" }
          },
          fill: { fgColor: { rgb: isEvenRow ? "F8FAFC" : "FFFFFF" } },
          alignment: { 
            horizontal: col === 0 ? "center" : "left",
            vertical: "center",
            wrapText: true
          },
          border: {
            top: { style: "thin", color: { rgb: "E5E7EB" } },
            bottom: { style: "thin", color: { rgb: "E5E7EB" } },
            left: { style: "thin", color: { rgb: "E5E7EB" } },
            right: { style: "thin", color: { rgb: "E5E7EB" } }
          }
        };
        
        // Special formatting for S.No column
        if (col === 0) {
          dataSheet[cellAddress].s.fill = { fgColor: { rgb: "EBF4FF" } };
          dataSheet[cellAddress].s.font.bold = true;
        }
      }
    }
    
    // Set row heights for better readability
    const rowHeights = [];
    for (let i = 0; i <= range.e.r; i++) {
      rowHeights.push({ hpx: i === 0 ? 25 : 20 }); // Header row taller
    }
    dataSheet['!rows'] = rowHeights;
    
    XLSX.utils.book_append_sheet(workbook, dataSheet, 'Extracted Data');
    
    // Generate filename with better naming convention
    const sanitizedTitle = (title || 'extraction-report')
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .replace(/\s+/g, '_')
      .toLowerCase();
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `${sanitizedTitle}_${timestamp}.xlsx`;
    
    // Add workbook properties
    workbook.Props = {
      Title: title || 'Data Extraction Report',
      Subject: 'AI-Generated Data Analysis',
      Author: 'Data Extractor Pro',
      CreatedDate: new Date()
    };
    
    // Download the file
    XLSX.writeFile(workbook, filename, {
      bookType: 'xlsx',
      type: 'buffer',
      compression: true
    });
    
    console.log(`Excel file '${filename}' generated successfully`);
    
  } catch (error) {
    console.error('Excel export error:', error);
    throw new Error(`Failed to generate Excel file: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};
